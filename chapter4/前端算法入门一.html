<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端算法入门一：刷算法题常用的JS基础扫盲 | react 快速上手</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="shortcut icon" type="image/x-icon" href="./images/favicon.ico">
    <meta name="description" content="杰哥哥前端研究院">
    
    <link rel="preload" href="/jiely/assets/css/0.styles.5afc0e25.css" as="style"><link rel="preload" href="/jiely/assets/js/app.77e16281.js" as="script"><link rel="preload" href="/jiely/assets/js/3.23c74d3c.js" as="script"><link rel="preload" href="/jiely/assets/js/28.7a75f195.js" as="script"><link rel="prefetch" href="/jiely/assets/js/10.7a1d5359.js"><link rel="prefetch" href="/jiely/assets/js/11.825d4d37.js"><link rel="prefetch" href="/jiely/assets/js/12.34a617ee.js"><link rel="prefetch" href="/jiely/assets/js/13.e956d670.js"><link rel="prefetch" href="/jiely/assets/js/14.24f14c4e.js"><link rel="prefetch" href="/jiely/assets/js/15.145280c2.js"><link rel="prefetch" href="/jiely/assets/js/16.8aed0633.js"><link rel="prefetch" href="/jiely/assets/js/17.55a0e136.js"><link rel="prefetch" href="/jiely/assets/js/18.6663a467.js"><link rel="prefetch" href="/jiely/assets/js/19.1d02f7a7.js"><link rel="prefetch" href="/jiely/assets/js/2.a217f65b.js"><link rel="prefetch" href="/jiely/assets/js/20.402bbfbb.js"><link rel="prefetch" href="/jiely/assets/js/21.13ffb241.js"><link rel="prefetch" href="/jiely/assets/js/22.9baa51a1.js"><link rel="prefetch" href="/jiely/assets/js/23.8b2d09f5.js"><link rel="prefetch" href="/jiely/assets/js/24.88446b74.js"><link rel="prefetch" href="/jiely/assets/js/25.212136bd.js"><link rel="prefetch" href="/jiely/assets/js/26.ab4c3f14.js"><link rel="prefetch" href="/jiely/assets/js/27.72b6ee76.js"><link rel="prefetch" href="/jiely/assets/js/29.20892189.js"><link rel="prefetch" href="/jiely/assets/js/30.7e88f712.js"><link rel="prefetch" href="/jiely/assets/js/31.dd681bb1.js"><link rel="prefetch" href="/jiely/assets/js/32.56daaef6.js"><link rel="prefetch" href="/jiely/assets/js/33.6a8234af.js"><link rel="prefetch" href="/jiely/assets/js/34.e75e2562.js"><link rel="prefetch" href="/jiely/assets/js/35.d15b5258.js"><link rel="prefetch" href="/jiely/assets/js/36.f706c7a4.js"><link rel="prefetch" href="/jiely/assets/js/37.02d520ec.js"><link rel="prefetch" href="/jiely/assets/js/38.3f565c1d.js"><link rel="prefetch" href="/jiely/assets/js/39.aac2a5de.js"><link rel="prefetch" href="/jiely/assets/js/4.8fe307c4.js"><link rel="prefetch" href="/jiely/assets/js/40.6ebf4f70.js"><link rel="prefetch" href="/jiely/assets/js/41.80e54647.js"><link rel="prefetch" href="/jiely/assets/js/42.b09ba0a7.js"><link rel="prefetch" href="/jiely/assets/js/43.4f1aa9ba.js"><link rel="prefetch" href="/jiely/assets/js/44.81f24246.js"><link rel="prefetch" href="/jiely/assets/js/45.b1f0b963.js"><link rel="prefetch" href="/jiely/assets/js/46.d01ff1ff.js"><link rel="prefetch" href="/jiely/assets/js/47.09ac9b9d.js"><link rel="prefetch" href="/jiely/assets/js/48.7c874e95.js"><link rel="prefetch" href="/jiely/assets/js/49.0931d234.js"><link rel="prefetch" href="/jiely/assets/js/5.8a58ce3d.js"><link rel="prefetch" href="/jiely/assets/js/6.9b54027d.js"><link rel="prefetch" href="/jiely/assets/js/7.f308a72a.js"><link rel="prefetch" href="/jiely/assets/js/8.a7efc970.js"><link rel="prefetch" href="/jiely/assets/js/9.1f369830.js">
    <link rel="stylesheet" href="/jiely/assets/css/0.styles.5afc0e25.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/jiely/" class="home-link router-link-active"><img src="/jiely/images/logo.jpg" alt="react 快速上手" class="logo"> <span class="site-name can-hide">react 快速上手</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://juejin.cn/post/7097067108663558151" target="_blank" rel="noopener noreferrer" class="nav-link external">
  50+Vue经典面试题源码级
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://segmentfault.com/a/1190000018604138" target="_blank" rel="noopener noreferrer" class="nav-link external">
  react面试题
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://juejin.cn/post/6844904055840440334" target="_blank" rel="noopener noreferrer" class="nav-link external">
  从零React项目
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://summerjie007.github.io/vue3_study/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Vue3+TS
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/airbnb/javascript" target="_blank" rel="noopener noreferrer" class="nav-link external">
  代码规范
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://juejin.cn/post/7097067108663558151" target="_blank" rel="noopener noreferrer" class="nav-link external">
  50+Vue经典面试题源码级
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://segmentfault.com/a/1190000018604138" target="_blank" rel="noopener noreferrer" class="nav-link external">
  react面试题
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://juejin.cn/post/6844904055840440334" target="_blank" rel="noopener noreferrer" class="nav-link external">
  从零React项目
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://summerjie007.github.io/vue3_study/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Vue3+TS
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/airbnb/javascript" target="_blank" rel="noopener noreferrer" class="nav-link external">
  代码规范
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/jiely/00_课程介绍.html" class="sidebar-link">课程指南</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>一.react全家桶上手</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>二.react全家桶项目</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>三.前端算法之道</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>前端算法入门一</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/jiely/chapter4/前端算法入门一.html" class="active sidebar-link">前端算法入门一：刷算法题常用的JS基础扫盲</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jiely/chapter4/前端算法入门一.html#前端算法入门一-刷算法题常用的js基础扫盲" class="sidebar-link">前端算法入门一：刷算法题常用的JS基础扫盲</a></li><li class="sidebar-sub-header"><a href="/jiely/chapter4/前端算法入门一.html#一、数组常用方法" class="sidebar-link">一、数组常用方法</a></li><li class="sidebar-sub-header"><a href="/jiely/chapter4/前端算法入门一.html#二、字符串常用方法" class="sidebar-link">二、字符串常用方法</a></li><li class="sidebar-sub-header"><a href="/jiely/chapter4/前端算法入门一.html#三、常用遍历方法-高阶函数" class="sidebar-link">三、常用遍历方法&amp;高阶函数</a></li><li class="sidebar-sub-header"><a href="/jiely/chapter4/前端算法入门一.html#四、常用正则表达式" class="sidebar-link">四、常用正则表达式</a></li><li class="sidebar-sub-header"><a href="/jiely/chapter4/前端算法入门一.html#五、数学知识" class="sidebar-link">五、数学知识</a></li><li class="sidebar-sub-header"><a href="/jiely/chapter4/前端算法入门一.html#参考文章" class="sidebar-link">参考文章</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>前端算法入门二</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>前端算法入门三</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>前端算法面试</span> <span class="arrow right"></span></p> <!----></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>四.JS设计设计模式</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>五.JS报错总结</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>六.Vue3+Pinia</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>七.node.js</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="前端算法入门一-刷算法题常用的js基础扫盲"><a href="#前端算法入门一-刷算法题常用的js基础扫盲" class="header-anchor">#</a> 前端算法入门一：刷算法题常用的JS基础扫盲</h2> <p>此篇属于前端算法入门系列的第一篇，主要介绍常用的<code>数组方法</code>、<code>字符串方法</code>、<code>遍历方法</code>、<code>高阶函数</code>、<code>正则表达式</code>以及相关<code>数学知识</code>。</p> <blockquote><p><strong>文章主要包含以下内容：</strong></p> <ul><li>数组常用方法</li> <li>字符串常用方法</li> <li>常用遍历方法&amp;高阶函数</li> <li>常用正则表达式</li> <li>数学知识</li></ul></blockquote> <h2 id="一、数组常用方法"><a href="#一、数组常用方法" class="header-anchor">#</a> 一、数组常用方法</h2> <h3 id="_1-push"><a href="#_1-push" class="header-anchor">#</a> 1.push()</h3> <p>在尾部追加，类似于压栈，原数组会变。</p> <div class="language- extra-class"><pre class="language-text"><code>const arr = [1, 2, 3]
arr.push(8)
console.log(arr) // [1, 2, 3, 8]
</code></pre></div><h3 id="_2-pop"><a href="#_2-pop" class="header-anchor">#</a> 2.pop()</h3> <p>在尾部弹出，类似于出栈，原数组会变。数组的 <code>push</code> &amp; <code>pop</code> 可以模拟常见数据结构之一：栈。</p> <div class="language- extra-class"><pre class="language-text"><code>const arr = [1, 2, 3]
const popVal = arr.pop()
console.log(popVal) // 3
console.log(arr) // [1, 2]

// 数组模拟常见数据结构之一：栈
const stack = [0, 1]
stack.push(2) // 压栈
console.log(stack) // [0, 1, 2]

const popValue = stack.pop() // 出栈
console.log(popValue) // 2
console.log(stack) // [0, 1]
</code></pre></div><h3 id="_3-unshift"><a href="#_3-unshift" class="header-anchor">#</a> 3.unshift()</h3> <p>在头部压入数据，类似于入队，原数组会变。</p> <div class="language- extra-class"><pre class="language-text"><code>const arr = [1, 2, 3]
arr.unshift(0)
console.log(arr) // [0, 1, 2, 3]
</code></pre></div><h3 id="_4-shift"><a href="#_4-shift" class="header-anchor">#</a> 4.shift()</h3> <p>在头部弹出数据，原数组会变。数组的 <code>push</code>（入队） &amp; <code>shift</code>（出队） 可以模拟常见数据结构之一：队列。</p> <div class="language- extra-class"><pre class="language-text"><code>const arr = [1, 2, 3]
const shiftVal = arr.shift()
console.log(shiftVal) // 1
console.log(arr) // [2, 3]

// 数组模拟常见数据结构之一：队列
const queue = [0, 1]
queue.push(2) // 入队
console.log(queue) // [0, 1, 2]

const shiftValue = queue.shift() // 出队
console.log(shiftValue) // 0
console.log(queue) // [1, 2]
</code></pre></div><h3 id="_5-concat"><a href="#_5-concat" class="header-anchor">#</a> 5.concat()</h3> <p><code>concat</code>会在当前数组尾部拼接传入的数组，然后返回一个新数组，原数组不变。</p> <div class="language- extra-class"><pre class="language-text"><code>const arr = [1, 2, 3]
const arr2 = arr.concat([7, 8, 9])
console.log(arr) // [1, 2, 3]
console.log(arr2) // [1, 2, 3, 7, 8, 9]
</code></pre></div><h3 id="_6-indexof"><a href="#_6-indexof" class="header-anchor">#</a> 6.indexOf()</h3> <p>在数组中寻找该值，找到则返回其下标，找不到则返回<code>-1</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>const arr = [1, 2, 3]
console.log(arr.indexOf(2)) // 1
console.log(arr.indexOf(0)) // -1
</code></pre></div><h3 id="_7-includes"><a href="#_7-includes" class="header-anchor">#</a> 7.includes()</h3> <p>在数组中寻找该值，找到则返回<code>true</code>，找不到则返回<code>false</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>const arr = [1, 2, 3]
console.log(arr.includes(2)) // true
console.log(arr.includes(4)) // false
</code></pre></div><h3 id="_8-join"><a href="#_8-join" class="header-anchor">#</a> 8.join()</h3> <p>将数组转化成字符串，并返回该字符串，不传值则默认逗号隔开，原数组不变。</p> <div class="language- extra-class"><pre class="language-text"><code>const arr = [1, 2, 3]
console.log(arr.join()) // ‘1, 2, 3’
console.log(arr) // [1, 2, 3]
</code></pre></div><h3 id="_9-reverse"><a href="#_9-reverse" class="header-anchor">#</a> 9.reverse()</h3> <p>翻转原数组，并返回已完成翻转的数组，原数组改变。</p> <div class="language- extra-class"><pre class="language-text"><code>const arr = [1, 2, 3]
console.log(arr.reverse()) // [3, 2, 1]
console.log(arr) // [3, 2, 1]
</code></pre></div><h3 id="_10-slice-start-end"><a href="#_10-slice-start-end" class="header-anchor">#</a> 10.slice(start，end)</h3> <p>从<code>start</code> 开始截取到<code>end</code>，但是不包括<code>end</code></p> <div class="language- extra-class"><pre class="language-text"><code>const arr = [1, 2, 3, 4, 5]
console.log(arr.slice(1, 4)) // [2, 3, 4]
console.log(arr) // [1, 2, 3, 4, 5]
</code></pre></div><h3 id="_11-splice-start-deletecount-item1-item2"><a href="#_11-splice-start-deletecount-item1-item2" class="header-anchor">#</a> 11.splice(start, deleteCount, item1, item2……)</h3> <ul><li><code>start</code>参数 开始的位置</li> <li><code>deleteCount</code>要截取的个数</li> <li>后面的<code>items</code>为要添加的元素</li> <li>如果<code>deleteCount</code>为<code>0</code>，则表示不删除元素，从<code>start</code>位置开始添加后面的几个元素到原始的数组里面。</li> <li>返回值为由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。</li> <li>这个方法会改变原始数组，数组的长度会发生变化</li></ul> <div class="language- extra-class"><pre class="language-text"><code>const arr3 = [1, 2, 3, 4, 5, 6, 7, &quot;f1&quot;, &quot;f2&quot;];
const arr4 = arr3.splice(2, 3) // 删除第三个元素以后的三个数组元素(包含第三个元素)
console.log(arr4); // [3, 4, 5];
console.log(arr3); // [1, 2, 6, 7, &quot;f1&quot;, &quot;f2&quot;]; 原始数组被改变

const arr5 = arr3.splice(2, 0, &quot;wu&quot;, &quot;leon&quot;); 
// 从第2位开始删除0个元素，插入&quot;wu&quot;,&quot;leon&quot;
console.log(arr5); // [] 返回空数组
console.log(arr3); // [1, 2, &quot;wu&quot;, &quot;leon&quot;, 6, 7, &quot;f1&quot;, &quot;f2&quot;]; 原始数组被改变

const arr6 = arr3.splice(2, 3, &quot;xiao&quot;, &quot;long&quot;);
// 从第 2 位开始删除 3 个元素，插入&quot;xiao&quot;, &quot;long&quot;
console.log(arr6); // [&quot;wu&quot;, &quot;leon&quot;, 6]
console.log(arr3); //[ 1, 2, &quot;xiao&quot;, &quot;long&quot;, 7, &quot;f1&quot;, &quot;f2&quot;]

const arr7 = arr3.splice(2); // 从第三个元素开始删除所有的元素
console.log(arr7);// [&quot;xiao&quot;, &quot;long&quot;, 7, &quot;f1&quot;, &quot;f2&quot;]
console.log(arr3); // [1, 2]
</code></pre></div><h3 id="_12-sort"><a href="#_12-sort" class="header-anchor">#</a> 12.sort()</h3> <ul><li>对数组的元素进行排序，并返回数组。</li> <li>默认排序顺序是在将元素转换为字符串，然后比较它们的<code>UTF-16</code>代码单元值序列时构建的。</li> <li>由于它取决于具体实现，因此无法保证排序的时间和空间复杂性。</li></ul> <p>可参考 <strong>MDN：Sort</strong>[5]</p> <div class="language- extra-class"><pre class="language-text"><code>const arr = [1, 2, 3]
arr.sort((a, b) =&gt; b - a)
console.log(arr) // [3, 2, 1]
</code></pre></div><h3 id="_13-tostring"><a href="#_13-tostring" class="header-anchor">#</a> 13.toString()</h3> <p>将数组转化成字符串，并返回该字符串，逗号隔开，原数组不变。</p> <div class="language- extra-class"><pre class="language-text"><code>const arr = [1, 2, 3, 4, 5]
console.log(arr.toString()) // ‘1, 2, 3, 4, 5’
console.log(arr) // [1, 2, 3, 4, 5]
</code></pre></div><h2 id="二、字符串常用方法"><a href="#二、字符串常用方法" class="header-anchor">#</a> 二、字符串常用方法</h2> <h3 id="_1-charat"><a href="#_1-charat" class="header-anchor">#</a> 1.charAt()</h3> <p>返回指定索引位置处的字符。类似于数组用中括号获取相应下标位置的数据。</p> <div class="language- extra-class"><pre class="language-text"><code>var str = 'abcdefg'
console.log(str.charAt(2)) // 输出 'c' 
console.log(str[2]) // 输出 'c'
</code></pre></div><h3 id="_2-concat"><a href="#_2-concat" class="header-anchor">#</a> 2.concat()</h3> <p>类似数组的concat()，用来返回一个合并拼接两个或两个以上字符串。原字符串不变。</p> <div class="language- extra-class"><pre class="language-text"><code>const str1 = 'abcdefg'
const str2 = '1234567'
const str3 = str1.concat(str2)
console.log(str3) // 输出 'abcdefg1234567'
</code></pre></div><h3 id="_3-indexof-、lastindexof"><a href="#_3-indexof-、lastindexof" class="header-anchor">#</a> 3.indexOf()、lastIndexOf()</h3> <p><code>indexOf</code>,返回一个字符在字符串中首次出现的位置,<code>lastIndexOf</code>返回一个字符在字符串中最后一次出现的位置。</p> <div class="language- extra-class"><pre class="language-text"><code>const str = 'abcdcefcg'
console.log(str.indexOf('c')) // 输出 '2'
console.log(str.lastIndexOf('c')) // 输出 '7'
</code></pre></div><h3 id="_4-slice"><a href="#_4-slice" class="header-anchor">#</a> 4.slice()</h3> <p>提取字符串的片断，并把提取的字符串作为新的字符串返回出来。原字符串不变。</p> <div class="language- extra-class"><pre class="language-text"><code>const str = 'abcdefg'
console.log(str.slice()) // 输出 'abcdefg', 不传递参数默认复制整个字符串
console.log(str.slice(1)) // 输出 'bcdefg',传递一个，则为提取的起点，然后到字符串结尾
console.log(str.slice(2, str.length-1)) // 输出'cdef',传递两个，为提取的起始点和结束点
</code></pre></div><h3 id="_5-split"><a href="#_5-split" class="header-anchor">#</a> 5.split()</h3> <p>使用指定的分隔符将一个字符串拆分为多个子字符串数组并返回，原字符串不变。</p> <div class="language- extra-class"><pre class="language-text"><code>const str = 'A*B*C*D*E*F*G'
console.log(str.split('*')) // 输出 [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;]
</code></pre></div><h3 id="_6-substr-substring"><a href="#_6-substr-substring" class="header-anchor">#</a> 6.substr(), substring()</h3> <ul><li>这两个方法的功能都是截取一个字符串的片段，并返回截取的字符串。</li> <li><code>substr</code>和<code>substring</code>这两个方法不同的地方就在于参数二，<code>substr</code>的参数二是截取返回出来的这个字符串指定的长度，<code>substring</code>的参数二是截取返回这个字符串的结束点，并且不包含这个结束点。而它们的参数一，都是一样的功能，截取的起始位置。</li> <li><strong>注意事项</strong>：<code>substr</code>的参数二如果为<code>0</code>或者负数，则返回一个空字符串，如果未填入，则会截取到字符串的结尾去。<code>substring</code>的参数一和参数二为<code>NAN</code>或者负数，那么它将被替换为<code>0</code>。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>const str = 'ABCDEFGHIJKLMN'
console.log(str.substr(2))  // 输出 'CDEFGHIJKLMN'
console.log(str.substring(2)) // 输出 'CDEFGHIJKLMN'

console.log(str.substr(2, 9))  // 输出 'CDEFGHIJK'
console.log(str.substring(2, 9))  // 输出 'CDEFGHI'
</code></pre></div><h3 id="_7-match"><a href="#_7-match" class="header-anchor">#</a> 7.match()</h3> <p><code>match()</code>方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配，并返回一个包含该搜索结果的数组。</p> <div class="language- extra-class"><pre class="language-text"><code>const str = '2018年结束了，2019年开始了，2020年就也不远了'
const reg = /\d+/g  // 这里是定义匹配规则，匹配字符串里的1到多个数字
console.log(str.match(reg))  // 输出符合匹配规则的内容，以数组形式返回 ['2018', '2019', '2020']
console.log(str.match('20'))  // 不使用正则 [&quot;20&quot;, index: 0, input: &quot;2018年结束了，2019年开始了&quot;]
</code></pre></div><p><strong>注意事项</strong>:如果<code>match</code>方法没有找到匹配，将返回<code>null</code>。如果找到匹配，则 <code>match</code>方法会把匹配到以数组形式返回，如果正则规则未设置全局修饰符<code>g</code>，则 <code>match</code>方法返回的数组有两个特性：<code>input</code>和<code>index</code>。<code>input</code>属性包含整个被搜索的字符串。<code>index</code>属性包含了在整个被搜索字符串中匹配的子字符串的位置。</p> <h3 id="_8-replace"><a href="#_8-replace" class="header-anchor">#</a> 8.replace()</h3> <p><code>replace</code>接收两个参数，参数一是需要替换掉的字符或者一个正则的匹配规则，参数二，需要替换进去的字符，仔实际的原理当中，参数二，你可以换成一个回调函数。</p> <div class="language- extra-class"><pre class="language-text"><code>const str = '2018年结束了，2019年开始了，2020年就也不远了'
const rex = /\d+/g  // 这里是定义匹配规则，匹配字符串里的1到多个数字
const str1 = str.replace(rex, '****') 
console.log(str1) // 输出：&quot;****年结束了，****年开始了,****年也不远了&quot;
const str2 = str.replace(rex, function(item){
    console.log(arguments)  // 看下面的图片
    const arr = ['零', '壹', '贰', '叁', '肆', '伍', '陆', '柒', '捌', '玖']
    let newStr = ''
    item.split('').map(function(i){
            newStr += arr[i]
    })     
    return newStr       
})
console.log(str2) // 输出：贰零壹捌年结束了，贰零壹玖年开始了,贰零贰零年也不远了
</code></pre></div><h3 id="_9-search"><a href="#_9-search" class="header-anchor">#</a> 9.search()</h3> <p>在目标字符串中搜索与正则规则相匹配的字符，搜索到，则返回第一个匹配项在目标字符串当中的位置，没有搜索到则返回一个<code>-1</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>const str = '2018年结束了，2019年开始了，2020年就也不远了'
const reg = /\d+/i  // 这里是定义匹配规则,匹配字符串里的1到多个数字
console.log(str.search(reg)) // 输出 0  这里搜索到的第一项是从位置0开始的
</code></pre></div><h3 id="_10-tolowercase-touppercase"><a href="#_10-tolowercase-touppercase" class="header-anchor">#</a> 10.toLowerCase(),toUpperCase()</h3> <p><code>toLowerCase</code>把字母转换成小写，<code>toUpperCase()</code>则是把字母转换成大写。</p> <div class="language- extra-class"><pre class="language-text"><code>const str1 = 'abcdefg'
const str2 = 'ABCDEFG'
console.log(str2.toLowerCase())  // 输出：'abcdefg'
console.log(str1.toUpperCase())  // 输出：'ABCDEFG'
</code></pre></div><h3 id="_11-includes-startswith-endswith"><a href="#_11-includes-startswith-endswith" class="header-anchor">#</a> 11.includes(), startsWith(), endsWith()</h3> <p><code>includes</code>、<code>startsWith</code>、<code>endsWith</code>，<code>es6</code>的新增方法，<code>includes</code> 用来检测目标字符串对象是否包含某个字符，返回一个布尔值，<code>startsWith</code>用来检测当前字符是否是目标字符串的起始部分，相对的<code>endwith</code>是用来检测是否是目标字符串的结尾部分。</p> <div class="language- extra-class"><pre class="language-text"><code>const str = 'Excuse me, how do I get to park road?'
console.log(str.includes('how')) // 输出：true
console.log(str.startsWith('Excuse')) // 输出： true
console.log(str.endsWith('?')) // 输出： true
</code></pre></div><h3 id="_12-repeat"><a href="#_12-repeat" class="header-anchor">#</a> 12.repeat()</h3> <p>返回一个新的字符串对象，新字符串等于重复了指定次数的原始字符串。接收一个参数，就是指定重复的次数。原字符串不变。</p> <div class="language- extra-class"><pre class="language-text"><code>const str = 'http'
const str2 = str.repeat(3)
console.log(str) // 输出：'http'
console.log(str2) // 输出：'httphttphttp'
</code></pre></div><h2 id="三、常用遍历方法-高阶函数"><a href="#三、常用遍历方法-高阶函数" class="header-anchor">#</a> 三、常用遍历方法&amp;高阶函数</h2> <h3 id="_1-for"><a href="#_1-for" class="header-anchor">#</a> 1.for()</h3> <p>最常用的<code>for</code>循环，经常用的数组遍历，也可以遍历字符串。</p> <div class="language- extra-class"><pre class="language-text"><code>const arr = [1, 2, 3]
const str = 'abc'
for (let i = 0; i &lt; arr.length; i++) {
    console.log(arr[i])
    console.log(str[i])
}
</code></pre></div><h3 id="_2-while-do-while"><a href="#_2-while-do-while" class="header-anchor">#</a> 2.while() / do while()</h3> <p><code>while</code>、<code>do while</code>主要的功能是，当满足<code>while</code>后边所跟的条件时，来执行相关业务。这两个的区别是，<code>while</code>会先判断是否满足条件，然后再去执行花括号里面的任务，而<code>do while</code>则是先执行一次花括号中的任务，再去执行<code>while</code>条件，判断下次还是否再去执行<code>do</code>里面的操作。也就是说 <strong>do while至少会执行一次操作</strong>.</p> <div class="language- extra-class"><pre class="language-text"><code>while(条件){
     执行...
}
------------
do{
    执行...
}
while(条件)
</code></pre></div><h3 id="_3-foreach"><a href="#_3-foreach" class="header-anchor">#</a> 3.forEach()</h3> <p>拷贝一份遍历原数组。</p> <ul><li><code>return</code>无法终止循环。不过可以起到<code>continue</code>效果。</li> <li>本身是不支持的<code>continue</code>与<code>break</code>语句的我们可以通过<code>some</code>和 <code>every</code>来实现。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>const arr = [5,1,3,7,4]
arr.forEach((item, index) =&gt; {
    if (item &lt; 2) return
    console.log(`索引：${index}，数值：${item}`)
    arr[5] = 0
})
console.log(arr)
// 打印结果：
// 索引：0，数值：5
// 索引：2，数值：3
// 索引：3，数值：7
// 索引：4，数值：4
// [5, 1, 3, 7, 4, 0]
</code></pre></div><h3 id="_4-for-in"><a href="#_4-for-in" class="header-anchor">#</a> 4.for...in</h3> <ul><li><code>for...in</code> 是 ES5 标准， 此方法遍历数组效率低，主要是用来循环遍历对象的属性。</li> <li>遍历数组的缺点：数组的下标<code>index</code>值是数字，<code>for-in</code>遍历的<code>index</code>值<code>&quot;0&quot;,&quot;1&quot;,&quot;2&quot;</code>等是字符串。</li> <li><code>Object.defineProperty</code>，建立的属性，默认不可枚举。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>const foo = {
    name: 'bar',
    sex: 'male'
}
Object.defineProperty(foo, &quot;age&quot;, { value : 18 })
for(const key in foo){
    console.log(`可枚举属性：${key}`)
}
console.log(`age属性：${foo.age}`)
// 打印结果：
// 可枚举属性：name
// 可枚举属性：sex
// age属性：18
</code></pre></div><h3 id="_5-for-of"><a href="#_5-for-of" class="header-anchor">#</a> 5.for...of</h3> <p><code>for…of</code>是<code>ES6</code>新增的方法，但是<code>for…of</code>不能去遍历普通的对象，<strong><code>for…of</code>的好处是可以使用<code>break</code>跳出循环。</strong></p> <ul><li><code>for-of</code>这个方法避开了<code>for-in</code>循环的所有缺陷</li> <li>与<code>forEach()</code>不同的是，它可以正确响应<code>break</code>、<code>continue</code>和<code>return</code>语句</li> <li><code>for-of</code>循环不仅支持数组，还支持大多数类数组对象，例如<code>DOM</code> <strong>NodeList对象</strong>[6]。</li> <li><code>for-of</code>循环也支持字符串遍历</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// for of 循环直接得到的就是值
const arr = [1, 2, 3]
for (const value of arr) {
 console.log(value)
}
</code></pre></div><p><strong>面试官：说一下 for...in 和 for...of 区别？</strong></p> <div class="language- extra-class"><pre class="language-text"><code>（1）for…in 用于可枚举数据，如对象、数组、字符串
（2）for…of 用于可迭代数据，如数组、字符串、Map、Set
</code></pre></div><h3 id="_6-every-some"><a href="#_6-every-some" class="header-anchor">#</a> 6.every / some</h3> <p><strong>返回一个布尔值</strong>。当我们需要判定数组中的元素是否满足某些条件时，可以使用<code>every</code> / <code>some</code>。这两个的区别是，<code>every</code>会去判断判断数组中的每一项，而 <code>some</code>则是当某一项满足条件时返回。</p> <div class="language- extra-class"><pre class="language-text"><code>// every
const foo = [5,1,3,7,4].every((item, index) =&gt; {
    console.log(`索引：${index}，数值：${item}`)
    return item &gt; 2
})
console.log(foo)
// every 打印：
// 索引：0，数值：5
// 索引：1，数值：1
// false
// some
const foo = [5,1,3,7,4].some((item, index) =&gt; {
    console.log(`索引：${index}，数值：${item}`)
    return item &gt; 2
})
console.log(foo)
// some 打印：
// 索引：0，数值：5
// true
</code></pre></div><h3 id="_7-filter"><a href="#_7-filter" class="header-anchor">#</a> 7.filter()</h3> <ul><li><code>filter</code>方法用于过滤数组成员，满足条件的成员组成一个新数组返回。</li> <li>它的参数是一个函数，所有数组成员依次执行该函数，返回结果为<code>true</code>的成员组成一个新数组返回。</li> <li>该方法不会改变原数组。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>const foo = [5,1,3,7,4].filter((item,index) =&gt; {
    console.log(`索引：${index}，数值：${item}`)
    return item &gt; 2
})
console.log(foo)
// 打印结果：
// 索引：0，数值：5
// 索引：1，数值：1
// 索引：2，数值：3
// 索引：3，数值：7
// 索引：4，数值：4
// [5, 3, 7, 4]
</code></pre></div><h3 id="_8-map"><a href="#_8-map" class="header-anchor">#</a> 8.map()</h3> <ul><li><code>map</code>即是 “映射”的意思 ，原数组被“映射”成对应新数组。</li> <li><code>map：</code>支持<code>return</code>，相当与原数组克隆了一份，把克隆的每项改变了，也不影响原数组。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>const foo = [5,1,3,7,4].map((item,index) =&gt; {
    console.log(`索引：${index}，数值：${item}`)
    return item + 2
})
console.log(foo)
// 打印结果：
// 索引：0，数值：5
// 索引：1，数值：1
// 索引：2，数值：3
// 索引：3，数值：7
// 索引：4，数值：4
// [7, 3, 5, 9, 6]
</code></pre></div><h3 id="_9-reduce-reduceright"><a href="#_9-reduce-reduceright" class="header-anchor">#</a> 9. reduce() / reduceRight()</h3> <p><code>reduce</code> 从左到右将数组元素做“叠加”处理，返回一个值。<code>reduceRight</code> 从右到左。</p> <div class="language- extra-class"><pre class="language-text"><code>const foo = [5,1,3,7,4].reduce((total, cur) =&gt; {
    console.log(`叠加：${total}，当前：${cur}`)
    return total + cur
})
console.log(foo)
// 打印结果：
// 叠加：5，当前：1
// 叠加：6，当前：3
// 叠加：9，当前：7
// 叠加：16，当前：4
// 20
</code></pre></div><h3 id="_10-object-keys遍历对象的属性"><a href="#_10-object-keys遍历对象的属性" class="header-anchor">#</a> 10.Object,keys遍历对象的属性</h3> <p><code>Object.keys</code>方法的参数是一个对象，返回一个数组。该数组的成员都是该对象自身的（而不是继承的）所有属性名，且只返回可枚举的属性。</p> <div class="language- extra-class"><pre class="language-text"><code>const obj = {
  p1: 123,
  p2: 456
};
Object.keys(obj) // [&quot;p1&quot;, &quot;p2&quot;]
</code></pre></div><h3 id="_11-object-getownpropertynames-遍历对象的属性"><a href="#_11-object-getownpropertynames-遍历对象的属性" class="header-anchor">#</a> 11.Object.getOwnPropertyNames() 遍历对象的属性</h3> <p><code>Object.getOwnPropertyNames</code>方法与<code>Object.keys</code>类似，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名。但它能返回不可枚举的属性。</p> <div class="language- extra-class"><pre class="language-text"><code>const arr = ['Hello', 'World'];
Object.keys(arr) // [&quot;0&quot;, &quot;1&quot;]
Object.getOwnPropertyNames(arr) // [&quot;0&quot;, &quot;1&quot;, &quot;length&quot;]
</code></pre></div><h3 id="以上遍历方法的区别"><a href="#以上遍历方法的区别" class="header-anchor">#</a> 以上遍历方法的区别：</h3> <div class="language- extra-class"><pre class="language-text"><code>一：map()，forEach()，filter()循环的共同之处：
  1.forEach，map，filter循环中途是无法停止的，总是会将所有成员遍历完。
  2.他们都可以接受第二个参数，用来绑定回调函数内部的 this 变量，将回调函数内部的 this 对象，指向第二个参数，间接操作这个参数（一般是数组）。

二：map()、filter()循环和forEach()循环的不同：
   forEach 循环没有返回值；map，filter 循环有返回值。

三：map()和filter()都会跳过空位，for 和 while 不会

四：some()和every():
   some()只要有一个是true，便返回true；而every()只要有一个是false，便返回false.

五：reduce()，reduceRight()：
   reduce是从左到右处理（从第一个成员到最后一个成员），reduceRight则是从右到左（从最后一个成员到第一个成员）。

六：Object对象的两个遍历 Object.keys 与 Object.getOwnPropertyNames：
   他们都是遍历对象的属性，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名。但Object.keys不能返回不可枚举的属性；Object.getOwnPropertyNames能返回不可枚举的属性。
</code></pre></div><h2 id="四、常用正则表达式"><a href="#四、常用正则表达式" class="header-anchor">#</a> 四、常用正则表达式</h2> <p>这里罗列一些我在刷算法题中遇到的正则表达式，如果有时间可认真学一下<strong>正则表达式不要背</strong>[7]。</p> <h3 id="_1-判断字符"><a href="#_1-判断字符" class="header-anchor">#</a> 1.判断字符</h3> <div class="language- extra-class"><pre class="language-text"><code>由26个英文字母组成的字符串：^[A-Za-z]+$
由26个大写英文字母组成的字符串：^[A-Z]+$
由26个小写英文字母组成的字符串：^[a-z]+$
由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$
</code></pre></div><h3 id="_2-判断数字"><a href="#_2-判断数字" class="header-anchor">#</a> 2.判断数字</h3> <div class="language- extra-class"><pre class="language-text"><code>数字：^[0-9]*$
</code></pre></div><p>持续更新，敬请期待……</p> <h2 id="五、数学知识"><a href="#五、数学知识" class="header-anchor">#</a> 五、数学知识</h2> <h3 id="_1-质数"><a href="#_1-质数" class="header-anchor">#</a> 1.质数</h3> <p>若一个正整数无法被除了<code>1</code> 和它自身之外的任何自然数整除，则称该数为质数（或素数），否则称该正整数为合数。</p> <div class="language- extra-class"><pre class="language-text"><code>function judgePrime(n) {
    for (let i = 2; i * i &lt;= n; i++) {
        if (n % i == 0) return false
    }
    return true
}
</code></pre></div><h3 id="_2-斐波那契数列"><a href="#_2-斐波那契数列" class="header-anchor">#</a> 2.斐波那契数列</h3> <div class="language- extra-class"><pre class="language-text"><code>function Fibonacci(n) {
    if (n &lt;= 1) return n  
    return Fibonacci(n - 1) + Fibonacci(n - 2)
}
</code></pre></div><p>持续更新，敬请期待……</p> <h2 id="参考文章"><a href="#参考文章" class="header-anchor">#</a> 参考文章</h2> <ul><li><strong>JavaScript 之字符串常用方法</strong>[8]</li> <li><strong>JavaScript 循环遍历大全</strong>[9]</li> <li><strong>刷算法题必备的数学考点汇总</strong>[10]</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/jiely/chapter3/06-打包优化.html" class="prev">
        项目打包和优化-项目打包
      </a></span> <span class="next"><a href="/jiely/chapter4/前端算法入门二.html">
        前端算法入门二：时间空间复杂度&amp;8大数据结构的JS实现
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/jiely/assets/js/app.77e16281.js" defer></script><script src="/jiely/assets/js/3.23c74d3c.js" defer></script><script src="/jiely/assets/js/28.7a75f195.js" defer></script>
  </body>
</html>
